[
    {
        "name": "ScrapRush",
        "thumbnail": "images/ScrapRushLogoBetter.png",
        "description": "A roguelike first person shooter with unlimited weapon customization.",
        "text": "Password to access the demo: scraprush\n\nScrapRush is a roguelike first person shooter game with over one decillion weapons for players to create. It started as a personal project to teach myself Unreal Engine, then became my Senior Thesis project for my Bachelor's degree in Interactive Multimedia at TCNJ. Since graduation, I have continued to work on the game and plan to eventually release it to the public. I also independently produced all music in Ableton Live 11 and created all 100+ inventory icons in Adobe Illustrator.\n\nThe core gameplay loop involves exploring a randomly generated world, collecting different \"scraps\" (bullet types or weapon modifiers), to defeat enemies in increasingly powerful ways. Each playthrough is unique due to the random layout of the map, with unique scraps found in each area. Players can create any weapon they can imagine, from a shotgun that shoots bouncing fireballs to a sniper rifle that fires homing rockets. The only limits are players' own creativity.\n\nThe custom weapon system is built using custom classes for weapons and bullets. There are six child weapon classes (pistol, shotgun, sniper rifle, assault rifle, rocket launcher, and knife) with unique behaviors or base stats. Each weapon has an array for scraps with a random size. This array simply stores enums for the 100+ scraps in the game. When firing a weapon, the weapon class loops through the scraps and applies modifiers until a bullet is fired. The modified values are then passed to the new bullet instance. Bullet types have attributes that can be modified by scraps, such as damage, speed, size, and special effects like homing or bouncing. Bullet classes also each have their own intrinsic behavior, usually determined by their unique implementation of the collision_behavior function. For example, a regular bullet will simply deal damage on impact, but an explosive bullet will create an area-of-effect.\n\nEnemies also have unique behaviors and attack patterns, created using behavior trees and blackboards. Additionally, the enemies exclusively use weapons made from the same weapon system as the player, allowing for a wide variety of enemy attack styles and allowing the player to reverse-engineer any enemy weapon they encounter.\n\nThe random map generation is done using a modular room system. Each room is a separate object that can be connected to other rooms via doorways. The map generator randomly selects and connects rooms to create a unique layout for each playthrough. Rooms are separated into categories based on area, where each area has a start and an end room, with themed rooms in between. This way, the generator can create a path from start to end, then add additional side rooms for exploration.\n\nOverall, working on ScrapRush has been an incredible learning experience that has improved my code quality, problem-solving skills, and ability to manage a large project independently. I have gained incredibly valuable experience in game design/development as this was the most technically challenging project I have ever worked on, and I am excited to continue developing the game and eventually share it with players around the world.",
        "images": ["images/scraprushimage1.png", "images/scraprushimage2.png", "images/scraprushimage3.png", "images/scraprushimage4.png", "images/scraprushimage5.png"],
        "tags": ["Unreal Engine", "Procedural Generation", "Game Development", "Ableton Live", "Adobe Illustrator", "Data Structures", "OOP", "Algorithms"],
        "date": "Aug 2024 - Present",
        "links": {
            "GitHub": "https://github.com/michael-bell-dev/ScrapRush",
            "Demo": "https://zmitter.itch.io/scraprush"
        },
        "slug": "scraprush"
    },
    {
        "name": "Automated Music Transcription",
        "thumbnail": "images/AutomatedMusicTranscription.png",
        "description": "Research in transcribing existing scores to new sets of instruments.",
        "text": "The automated music transcription project aims to develop an algorithm that takes an existing score and generate a new arrangement with any set of instruments that is both playable and faithful to the original. Previous students have advanced this project to the point where a polyphonic part can be reduced to a limited number of simultaneous voices, split into separate monophonic lines, and assigned to specific monophonic instruments, all while preserving the integrity of the piece. While their contributions can create scores for monophonic instruments, we can not yet validate parts for polyphonic instruments. My work focuses on bridging this gap towards polyphony by creating an algorithm that determines if a score is playable by a single pianist.\n\nUsing the Music21 Python library, my program takes into account three main constraints for piano playability: maximum number of notes, maximum intervals between fingers, and tied notes locking fingers in place. The program assumes a finger can play up to 2 notes, if those notes are consecutive white keys. Additionally, the thumb is allowed to play consecutive black keys. This leads to an absolute maximum of 20 notes at once, or 10 fingers, before a chord is automatically assumed to be impossible. The program then checks the intervals between notes to ensure that no finger is required to stretch beyond what is possible for the user. At runtime, a txt file is read where the user can customize their own maximum hand span and finger distances so the algorithm checks playability for their specific hand size. Finally, tied notes are checked to ensure they remain in the same hand, and can be entirely moved to the other hand's part if it creates complications.\n\nThe program outputs a new MusicXML file containing the new piano arrangement of the piece. Any chords determined to be unplayable are highlighted in red for the user to clearly see. Hand assignments are generally very intuitive, with a realistic left- and right-hand split. In testing, the algorithm has correctly classified every piece as playable or unplayable according to the human pianist's hand limitations.\n\nFuture work will expand this algorithm to other polyphonic instruments, such as the guitar. A general polyphonic validation framework with customizable rules for each instrument, when merged with the previous reduction, separation, and arrangement work that has already been done, would allow for a complete system capable of automatically arranging any score into a new playable arrangement for any set of monophonic or polyphonic instruments.\n\nOverall, this project made me a better researcher and programmer by working with a complex library like Music21 and implementing advanced algorithms to solve a real-world problem in music transcription and arrangement.",
        "images": ["images/automatedmusictranscriptionimage1.jpg", "images/automatedmusictranscriptionimage2.png", "images/automatedmusictranscriptionimage3.png", "images/automatedmusictranscriptionimage4.png"],
        "tags": ["Python", "Music21", "XML", "Algorithms", "OOP"],
        "date": "May 2025 - Dec 2025",
        "links": {
            "GitHub": "https://github.com/michael-bell-dev/music21_piano_validation"
        },
        "slug": "automated-music-transcription"
    },
    {
        "name": "LA NCSA Website",
        "thumbnail": "images/NCSA.png",
        "description": "Migrating an existing website from NationBuilder to Wix.",
        "text": "The Los Angeles Neighborhood Council Sustainability Alliance (LA NCSA) is a nonprofit organization focused on promoting sustainability initiatives within local communities. Their previous website was built on the NationBuilder platform, which presented several challenges to the team. As a volunteer web developer, I was tasked with migrating the website to Wix, a more user-friendly and flexible platform.\n\nThe migration process involved several key steps. First, I created an event system similar to the one they used on NationBuilder, allowing them to easily manage new events, with automatic addition to the \"Past Events\" page after the event date. This was done originally using a custom CMS table and JavaScript to dynamically generate event cards, as the automatic past events feature was the most important feature to the client. This also saved the client from having to manually create a static page for each event, which was what they did in their previous site. After further discussion with the client, I transfered this functionallity to the built in Event system in Wix, which provides a more robust event management system.\n\nNext, I created a custom contact form that adds new submissions to a Wix database, allowing for easy management of inquiries and bulk emails. Custom logic was required to include each new menber's Neighborhood Council in the built in Contact database, allowing the client to filter contacts by Neighborhood Council when sending bulk emails.\n\nFinally, I migrated all existing static content from the old website to the new website, ensuring that all information was accurate and up-to-date. This involved manually copying text and importing images and pdfs to the new site. I also ensured that any links to other pages, events, or custom media were replaced with the new Wix links.\n\nOverall, the migration process was successful, and the new Wix website provided the LA NCSA with a more user-friendly and flexible platform to manage their online presence. I included documentation for the client to easily update and maintain the website in the future.",
        "images": ["images/ncsaimage1.png", "images/ncsaimage2.png", "images/ncsaimage3.png", "images/ncsaimage4.png", "images/ncsaimage5.png", "images/ncsaimage6.png"],
        "tags": ["JavaScript", "Web Development", "CSV", "Wix"],
        "date": "Sep 2025 - Dec 2025",
        "links": {
            "Website": "https://lisahart5.wixsite.com/lancsa"
        },
        "slug": "la-ncsa-website"
    },
    {
        "name": "Deep Learning Neural Network",
        "thumbnail": "images/pytorch-logo-1.png",
        "description": "Simple AI model created with supervised learning techniques.",
        "text": "The objectives of this Data Science project were to practice defining and training neural network models using PyTorch and exploring the impact of neural network hidden layer size on its ability to capture complex patterns in a synthetic data set.\n\nI generated a synthetic classification dataset using a set of Y vs (X1, X2) data based on a mathmatical model for both X1 and X2 in a specified range. This data was then passed through a signum function, which returns 1 for positive numbers and -1 for negative numbers. Using a PyTorch neural network models with two fully connected linear layers and one hidden sigmoidal layer, I trained versions of the model with different numbers of neurons that make up the single hidden layer. After training was complete, the ability of each model to properly classify the data was assesed by observing the final training loss and calculating the model accuracy.\n\nThe results of this experiment showed that as the number of neurons in the hidden layer increased, the model's ability to capture complex patterns in the data improved. Models with larger hidden layers achieved lower training losses and higher accuracies, indicating that they were better able to learn the underlying relationships in the data. However, there were diminishing returns as the hidden layer size increased, with very large hidden layers showing only marginal improvements in performance compared to moderately sized ones. This suggests that while increasing model complexity can enhance learning, there is a point beyond which additional complexity yields limited benefits.\n\nOverall, this project provided valuable insights into the relationship between neural network architecture and performance, highlighting the importance of selecting an appropriate model size for effective learning.",
        "images": ["images/pytorchimage1.png", "images/pytorchimage2.png", "images/pytorchimage3.png", "images/pytorchimage4.png", "images/pytorchimage5.png", "images/pytorchimage6.png", "images/pytorchimage7.png"],
        "tags": ["AI", "Python", "PyTorch", "Jupyter Notebook", "Data Science", "CSV", "Deep Learning", "Neural Network"],
        "date": "Nov 2025 - Dec 2025",
        "links": {
        },
        "slug": "deep-learning-neural-network"
    },
    {
        "name": "Portfolio Website",
        "thumbnail": "images/michaelbelldev.png",
        "description": "Stylized website to display my past and current projects.",
        "text": "This portfolio website was created to showcase my skills and projects as a developer. Built using HTML, CSS, and JavaScript, the website features a clean design that highlights my work in an organized manner. The site includes a search function to easily find projects based on title or tags. The site is hosted on GitHub Pages for easy access and sharing. Overall, this portfolio website serves as a professional platform to present my development experience and capabilities.",
        "images": [],
        "tags": ["HTML", "CSS", "JavaScript", "JSON", "Web Development"],
        "date": "Nov 2025 - Present",
        "links": {
            "GitHub": "https://github.com/michael-bell-dev/michael-bell-dev.github.io",
            "Website": "https://michael-bell-dev.github.io/"
        },
        "slug": "portfolio-website"
    },
    {
        "name": "Monster Battle Arena",
        "thumbnail": "images/MonsterBattleArena.png",
        "description": "A text based battle simulation between different monster types.",
        "text": "The goal of this project was to create a turn-based console text game using C++ in which two teams of monsters battle. This battle simulation has each team line up single file to face the other, with only the lead monster taking an action each turn. For every turn, the lead monster attacks the opposing lead monster, dealing damage and using any abilities it possesses. If a monster's health reaches zero, it is removed from the battle and the next monster in line takes its place. The battle continues until one team has no remaining monsters.\n\nEach monster belongs to a specific class, such as Goblin, Troll, or Orc, each with unique attributes and abilities. These classes are implemented using inheritance and polymorphism to allow for easy expansion and modification of monster types. Overall, this project provided valuable experience in C++ programming, object-oriented design principles, and implementing game mechanics in a console application. Additionally, it taught me how to properly balance game elements to create an engaging experience, as the three monster types work in a rock-paper-scissors-esque relationship.",
        "images": [],
        "tags": ["C++", "Game Development", "OOP"],
        "date": "Sept 2025 - Oct 2025",
        "links": {
        },
        "slug": "monster-battle-arena"
    },
    {
        "name": "Workwell Job Board",
        "thumbnail": "images/Workwell.png",
        "description": "Job board web page for Workwell Partnership.",
        "text": "This project involved creating a job board web page for Workwell Partnership, a nonprofit organization based in Trenton, NJ, to help returning citizens find jobs. The site was built in a team of four using Ruby on Rails, PostgreSQL, and Bootstrap. In addition to the job posting database, the application included user authentication, job posting functionality, and a search feature to filter jobs by various criteria. The design focused on accessibility and ease of use, ensuring that users could easily navigate the site and find relevant job listings. New job listings can be posted by users of \"Graduate\" role or above, and these listings must be approved by users of \"Admin\" role or above before they can be seen by other users on the board itself. The site also features a dynamic page system for each job, including all necessary job information and a nested comment system for users to ask questions or reply to other users.\n\nOverall, the project provided valuable experience in full-stack web development, teamwork, and working with real-world clients to meet their needs.",
        "images": [],
        "tags": ["Ruby", "PostgreSQL", "HTML", "CSS", "JavaScript", "BootStrap", "Rails", "MVC", "Web Development", "Linux"],
        "date": "Feb 2025 - May 2025",
        "links": {
        },
        "slug": "workwell-job-board"
    },
    {
        "name": "Dinner Rush",
        "thumbnail": "images/dinnerrush.png",
        "description": "A restaurant game where you take orders, make pizza, and bus tables.",
        "text": "Dinner Rush is a time-management game developed in Unity using C# in a team of three. The game challenges players to efficiently manage a restaurant by taking customer orders, preparing food, and cleaning tables. Score is based on customer satisfaction and speed of service. The game features multiple levels with increasing difficulty, introducing new challenges such as more complex orders and a higher volume of customers. Players must balance their time and resources to keep the restaurant running smoothly and achieve high scores.\n\nOverall, this project provided valuable experience in game development, teamwork, and implementing game mechanics in Unity.",
        "images": [],
        "tags": ["Unity", "C#", "Game Development", "OOP"],
        "date": "Apr 2025 - May 2025",
        "links": {
        },
        "slug": "dinner-rush"
    },
    {
        "name": "JobLinker",
        "thumbnail": "images/Joblinker.png",
        "description": "An endorsement-based job searching platform.",
        "text": "JobLinker is a job searching platform developed in Ruby on Rails with a PostgreSQL database. This platform allows users to create profiles as either job seekers or employers. Job seekers can browse and apply for job listings, while employers can post job openings and review applications. A unique feature of JobLinker is its endorsement system, where employers can endorse job seekers they have previously hired, enhancing the credibility of applicants. Job seekers can also endorse employers based on their own experience if they have been hired by them in the past. This creates a network of trust and reliability within the platform, helping users make informed decisions when applying for jobs or hiring candidates.\n\nThe platform includes user authentication, profile management, job posting functionality, and a search feature to filter jobs by various criteria. The design focuses on user experience, ensuring that both job seekers and employers can easily navigate the site and access relevant information. For example, job seekers can easily view the status of every job they've applied for on their profile and can search for a specific application if they so desire.\n\nOverall, JobLinker provides a comprehensive solution for job searching and hiring, leveraging endorsements to build a trustworthy community. The project offered valuable experience in full-stack web development, database management, and user-centric design.",
        "images": [],
        "tags": ["Ruby", "PostgreSQL", "HTML", "CSS", "JavaScript", "BootStrap", "Rails", "MVC", "Web Development", "Linux"],
        "date": "Feb 2025 - Apr 2025",
        "links": {
        },
        "slug": "joblinker"
    },
    {
        "name": "Multiplayer Character Selection",
        "thumbnail": "images/Networking.png",
        "description": "Pick your character and enter a world with friends.",
        "text": "This is an independent experiment combining two computer science labs on computer networking and persistent data storage. The goal of this experiment was to create a multiplayer framework in Unity that allows players to select a character from a list, type their username, and enter a shared online world with other players. Data such as name and character are stored using a custom persistent class made using C#, and networking is handled using Unity.netcode with NetworkVariables sending and receiving data from the server to all connected clients.\n\nOverall, this project provided valuable insights into multiplayer game development, networking protocols, and data persistence techniques within the Unity engine, and will act as a foundation for future multiplayer projects.",
        "images": ["images/multiplayer1.png", "images/multiplayer2.png", "images/multiplayer3.png"],
        "tags": ["Computer Networking", "Unity", "C#", "Game Development"],
        "date": "Mar 2025 - Apr 2025",
        "links": {
        },
        "slug": "multiplayer-online-character-selection-system"
    },
    {
        "name": "Scheduler App",
        "thumbnail": "images/scheduler.png",
        "description": "Automatically book available rooms using the date and duration of your event.",
        "text": "This app created in Ruby allows users to input the date and duration of an event they are looking to schedule, along with the anticipated number of attendees. The app then searches through a CSV file containing all rooms, which includes information about building, room number, capacity, and whether food is permitted in the room. It reads another CSV file containing all existing bookings, including date, start time, end time, and room. Using this information, the app determines which rooms are available for the requested date and time that also meet the capacity requirement. There are various checks that the app performs to ensure that the event runs as smoothly as possible. For example, events will only be scheduled in a single building if multiple rooms are required. Addionally, certain requirements for HackTCNJ events are automatically enforced, such as requiring both group and individual work rooms, as well as meal breaks every 6 hours. An hour long intro and outro session are also automatically added to HackTCNJ events, which must be held in a single room that can hold the entire capacity of the eveny.\n\nOverall, this project provided valuable experience in Ruby programming, data manipulation using CSV files, and implementing scheduling algorithms to efficiently allocate resources based on user requirements.",
        "images": [],
        "tags": ["Ruby", "CSV", "Data Structures", "Algorithms", "OOP"],
        "date": "Feb 2025 - Mar 2025",
        "links": {
        },
        "slug": "scheduler-app"
    },
    {
        "name": "Rocket League Recreation",
        "thumbnail": "images/rocketleague.png",
        "description": "Simple recreation of a popular game using Unity.",
        "text": "This recreation of Rocket League was built in Unity and programmed in C#. The game features all of the core mechanics and controls of the original game, including driving, boosting, jumping, and powersilding. The physics of the car and ball were tuned using the Unity rigidbody system until it felt fun to use. The game includes a basic AI opponent system where the AI will attempt to chase the ball and jump at random intervals.\n\nA game design document was also written to outline the core mechanics, controls, and features of the game. This document served as a guide throughout the development process, ensuring that the final product aligned with the original vision for the game. This taught me how to think more abstractly in terms of the high concept and key features, and showed me the importance of understanding the first minute, gameflow, and victory conditions.\n\nOverall, this project provided valuable experience in game development using Unity, physics tuning, AI programming, and game design documentation.",
        "images": ["images/rocketleagueimage1.png", "images/rocketleagueimage2.png", "images/rocketleagueimage3.png"],
        "tags": ["Unity", "C#", "Game Development"],
        "date": "Feb 2025 - Mar 2025",
        "links": {
        },
        "slug": "rocket-league-recreation"
    },
    {
        "name": "YellowRose",
        "thumbnail": "images/YellowRose.png",
        "description": "Audio sampler VST plugin with ADSR envelope and custom time-jumping algorithm.",
        "text": "YellowRose is an audio sampler VST plugin built using C++ and the JUCE framework. It features a simple interface that allows users to drag and drop audio files into the plugin, which will appear visually as a waveform. Users can then play this audio using MIDI input, with the ability to adjust the pitch and playback speed based on the MIDI note played. The plugin also includes an ADSR envelope, allowing users to shape the amplitude of the audio over time by adjusting the attack, decay, sustain, and release parameters.\n\nThe key feature of YellowRose is its custom time-jumping algorithm, which allows for unique playback effects. This algorithm enables users to create stutter effects, glitchy sounds, and other time-based manipulations by jumping to different points in the audio sample during playback. This adds a layer of creativity and flexibility to the plugin, making it suitable for a wide range of musical styles and applications. This algorithm has two user-defined parameters that allow for fine-tuning of the time-jumping behavior, which are \"Time to chop\" and \"Frequency.\" Time to chop is how far forwards or backwards the algorithm jumps during playback, and frequency is how often this should occur. Short jumps at a high frequency add interesting textures to sounds, while longer jumps at a low frequency create more dramatic and glitchy effects.\n\nOverall, this project provided valuable experience in audio programming, VST plugin development, and working with digital signal processing techniques using C++ and JUCE. It also gave me important experience working in an unfamiliar framework and learning how to navigate documentation and resources to achieve my goals.",
        "images": ["images/yellowroseimage1.png", "images/yellowroseimage2.png"],
        "tags": ["C++", "VST", "JUCE"],
        "date": "Nov 2024 - Dec 2024",
        "links": {
        },
        "slug": "yellowrose"
    },
    {
        "name": "Animal Farm",
        "thumbnail": "images/animalfarm.png",
        "description": "Animal matching game for children with voice-controlled navigation.",
        "text": "Animal Farm is a simple animal matching game developed by a team of four. The game is designed for children, with a focus on accessability by including voice controls for navigation and selection. Players can use voice commands to select animals and navigate through the game menus, making it easier for young children to play without needing to use a keyboard or mouse. These voice recognition features were made possible by the use of the Hugging Face API, and create a much more engaging experience for players.\n\nThe game features colorful graphics and engaging sound effects to create an enjoyable experience for players. The core gameplay loop involves matching an animal to its silhouette. Upon a successful match, the player is rewarded by adding that animal to their farm. The player is also prompted to make that animal's sound with their voice, which is recorded. This sound will be played back if the player clicks on that animal on their farm.\n\nOverall, this project provided valuable experience in Unity game development, voice recognition integration, and teamwork in a collaborative environment.",
        "images": ["images/animalfarmimage1.png", "images/animalfarmimage2.png", "images/animalfarmimage3.png", "images/animalfarmimage4.png"],
        "tags": ["Unity", "C#", "AI", "Voice Recognition", "Hugging Face API",  "Game Development", "HCI"],
        "date": "Nov 2024 - Dec 2024",
        "links": {
        },
        "slug": "animal-farm"
    },
    {
        "name": "Service Agent",
        "thumbnail": "images/agent.png",
        "description": "AI voice assistant with voice controlled commands.",
        "text": "This simple service agent was built in Python to practice working with voice recognition and text-to-speech APIs. The agent listens for voice commands from the user, processes them using the speech_recognition library, and responds with synthesized speech using the pyttsx3 library. The agent can perform basic tasks such as answering questions about account information, providing technical support, providing product information, and directing users to relevant resources. The agent is designed to be user-friendly and efficient, providing quick and accurate responses to user inquiries. Navigation is also made easy, as the user will be taken backwards by a step if they say \"back.\"",
        "images": [],
        "tags": ["AI", "Python", "Voice Recognition", "pyttsx3"],
        "date": "Nov 2024 - Dec 2024",
        "links": {
        },
        "slug": "service-agent"
    },
    {
        "name": "Motion Detector",
        "thumbnail": "images/HandRaise.png",
        "description": "Object tracking algorithm to detect raised hands, nodding, and shaking your head.",
        "text": "This project uses Google's opensource MediaPipe framework to implement a motion detection algorithm in Python. The program uses a webcam to capture live video feed and processes each frame to detect specific motions: raised hands, nodding, and shaking your head. By analyzing the position and movement of key facial landmarks and body parts, the algorithm can accurately identify these motions in real-time. This project provided valuable experience in computer vision, motion detection algorithms, and working with the MediaPipe framework.",
        "images": ["images/motiondetectorimage1.png", "images/motiondetectorimage2.png"],
        "tags": ["AI", "Python", "Computer Vision", "MediaPipe"],
        "date": "Nov 2024 - Dec 2024",
        "links": {
        },
        "slug": "motion-detector"
    },
    {
        "name": "Client-Server Chatroom",
        "thumbnail": "images/chatroom.png",
        "description": "Live chatroom with room selection.",
        "text": "In a team of two, I developed a client-server chatroom application using C and socket programming. The application allows multiple clients to connect to a central server and join different chat rooms to communicate with each other in real-time. The server manages the connections and routes messages between clients in the same chat room. Clients on the otherhand can send and receive messages. The application is designed to be efficient and scalable, allowing for a large number of concurrent users. Both the client and server programs use multiple threads to handle incoming and outgoing messages simultaneously, ensuring smooth communication without delays.\n\nClients can choose from a list of available chat rooms upon connecting to the server, or they can start their own. Upon joining a room, clients create a username for themselves, and are assigned a random color to differentiate their messages from others. The chat interface displays messages in real-time, with each message prefixed by the sender's username in their assigned color. The server handles new users joining and leaving the chatroom, and will print a message to the room when this occurs.\n\nThis project provided valuable experience in network programming, multithreading, and socket communication using C.",
        "images": [],
        "tags": ["C", "Computer Networking", "Multithreading", "Sockets"],
        "date": "Apr 2024 - May 2024",
        "links": {
        },
        "slug": "client-server-chatroom"
    },
    {
        "name": "Silvies Valley Ranch Database",
        "thumbnail": "images/Silvies.jpg",
        "description": "Website for tracking goat deaths per season/year.",
        "text": "In a team of three, I developed a web application for Silvies Valley Ranch to track kid goat deaths over time using a custom PostgreSQL database. The application allows ranch staff to log goat deaths with relevant details such as date and age. I created nine useful queries to analyze the data, including total deaths per season/year, average age at death, and average weaning, winter, and sale weight of the goats. I also created a quiery to find the standard deviation, but as it was a PostgreSQL query doing complex math, it was incredibly slow to run on the large datasets, so it was ultimately not included in the final application.\n\nThe web interface was built using HTML, CSS, and JavaScript, providing a user-friendly way for staff to view graphical reports. Overall, this project provided valuable experience in database design, SQL querying, and full-stack web development.",
        "images": [],
        "tags": ["PostgreSQL", "JavaScript", "HTML", "CSS", "Web Development", "Linux"],
        "date": "Mar 2024 - May 2024",
        "links": {
        },
        "slug": "silvies-valley-ranch-database"
    },
    {
        "name": "Virtual Memory System",
        "thumbnail": "images/VirtualMemory.png",
        "description": "Compares efficiency of caching algorithms: FIFO and LRU",
        "text": "In a team of two, I developed a virtual memory system in C to compare the efficiency of two caching algorithms: FIFO (First-In-First-Out) and LRU (Least Recently Used). The system simulates a virtual memory environment and tracks how each algorithm performs in terms of cache hits and misses. The project involved implementing each algorithm from scratch, analyzing their performance on various data access patterns, and comparing their effectiveness in managing memory resources. The results of the simulations provided insights into the strengths and weaknesses of each caching strategy, helping to understand their practical applications in real-world systems. This project provided valuable experience in C programming, algorithm implementation, and performance analysis.",
        "images": [],
        "tags": ["C", "Cache", "Linux"],
        "date": "Mar 2024 - Apr 2024",
        "links": {
        },
        "slug": "virtual-memory-system"
    },
    {
        "name": "Command Line Terminal",
        "thumbnail": "images/commandterminal.png",
        "description": "A command line terminal that mimics Linux terminal functionality.",
        "text": "I developed a command line terminal in C that mimics the functionality of a standard Linux terminal. The terminal supports common commands such as ls, cd, pwd, and echo, along with the ability to run external programs. It also includes features like tab completion for commands and file names, and the ability to redirect output to files or pipes. The project involved implementing a shell that can parse and execute commands, handle input/output redirection, and manage processes. This project provided valuable experience in C programming, system calls, and process management.",
        "images": [],
        "tags": ["C", "Linux"],
        "date": "Feb 2024 - Mar 2024",
        "links": {
        },
        "slug": "command-line-terminal"
    },
    {
        "name": "Dream Defender",
        "thumbnail": "images/dreamdefender.png",
        "description": "Prototype of a combat based platformer.",
        "text": "In a team of five, I developed a prototype for Dream Defender, a combat-based platformer game built in Unity using C#. The game features combat mechanics, platforming challenges, and a variety of enemy types. Players control a character who must navigate through a map filled with obstacles and enemies. The prototype focuses on refining the core gameplay mechanics, ensuring responsive and fun controls on keyboard and gamepad such as dashing, walljumping, pogoing, and koyote time. This project provided valuable experience in Unity game development, teamwork, and implementing complex game mechanics.",
        "images": ["images/dreamdefenderimage1.png", "images/dreamdefenderimage2.png", "images/dreamdefenderimage3.png", "images/dreamdefenderimage4.png", "images/dreamdefenderimage5.png"],
        "tags": ["Unity", "C#", "Game Development"],
        "date": "Feb 2024 - May 2024",
        "links": {
            "Demo": "https://zmitter.itch.io/dream-defender"
        },
        "slug": "dream-defender"
    },
    {
        "name": "Music Box",
        "thumbnail": "images/musicbox.png",
        "description": "Music-based sequential puzzle game with live music editing.",
        "text": "Music Box is a music-based sequential puzzle game developed in Unity using C#. The game features a unique mechanic where players can edit the background music in real-time using in-game interfaces. Using this custom audio system I created, players can input melodies, add/alter instruments, adjust drum patterns, and even play the piano to solve puzzles and progress through levels. The game challenges players to think creatively about how music can influence gameplay, requiring them to manipulate the soundtrack to unlock new puzzles to solve. This project provided valuable experience in Unity game development, audio programming, and integrating music editing features into gameplay.",
        "images": ["images/musicboximage1.png", "images/musicboximage2.png", "images/musicboximage3.png", "images/musicboximage4.png", "images/musicboximage5.png", "images/musicboximage6.png"],
        "tags": ["Unity", "C#", "Game Development", "Ableton Live", "Adobe Photoshop"],
        "date": "Nov 2023 - Dec 2023",
        "links": {
            "Demo": "https://zmitter.itch.io/music-box"
        },
        "slug": "music-box"
    }

]
